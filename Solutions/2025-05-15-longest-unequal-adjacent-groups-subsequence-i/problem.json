{
  "title": "Longest Unequal Adjacent Groups Subsequence I",
  "titleSlug": "longest-unequal-adjacent-groups-subsequence-i",
  "questionFrontendId": "2900",
  "translatedTitle": "",
  "difficulty": "Easy",
  "content": "\u003Cp\u003EYou are given a string array \u003Ccode\u003Ewords\u003C/code\u003E and a \u003Cstrong\u003Ebinary\u003C/strong\u003E array \u003Ccode\u003Egroups\u003C/code\u003E both of length \u003Ccode\u003En\u003C/code\u003E, where \u003Ccode\u003Ewords[i]\u003C/code\u003E is associated with \u003Ccode\u003Egroups[i]\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EYour task is to select the \u003Cstrong\u003Elongest alternating\u003C/strong\u003E \u003Cspan data-keyword=\u0022subsequence-array\u0022\u003Esubsequence\u003C/span\u003E from \u003Ccode\u003Ewords\u003C/code\u003E. A subsequence of \u003Ccode\u003Ewords\u003C/code\u003E is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array \u003Ccode\u003Egroups\u003C/code\u003E differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the \u003Ccode\u003Egroups\u003C/code\u003E array.\u003C/p\u003E\n\n\u003Cp\u003EFormally, you need to find the longest subsequence of an array of indices \u003Ccode\u003E[0, 1, ..., n - 1]\u003C/code\u003E denoted as \u003Ccode\u003E[i\u003Csub\u003E0\u003C/sub\u003E, i\u003Csub\u003E1\u003C/sub\u003E, ..., i\u003Csub\u003Ek-1\u003C/sub\u003E]\u003C/code\u003E, such that \u003Ccode\u003Egroups[i\u003Csub\u003Ej\u003C/sub\u003E] != groups[i\u003Csub\u003Ej\u002B1\u003C/sub\u003E]\u003C/code\u003E for each \u003Ccode\u003E0 \u0026lt;= j \u0026lt; k - 1\u003C/code\u003E and then find the words corresponding to these indices.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe selected subsequence. If there are multiple answers, return \u003Cstrong\u003Eany\u003C/strong\u003E of them.\u003C/em\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003ENote:\u003C/strong\u003E The elements in \u003Ccode\u003Ewords\u003C/code\u003E are distinct.\u003C/p\u003E\n\n\u003Cp\u003E\u0026nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\u0022example\u0022\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\u0022example-block\u0022 style=\u0022\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\u0022\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003Ewords = [\u0026quot;e\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;], groups = [0,0,1]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003E[\u0026quot;e\u0026quot;,\u0026quot;b\u0026quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E A subsequence that can be selected is \u003Ccode\u003E[\u0026quot;e\u0026quot;,\u0026quot;b\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[2]\u003C/code\u003E. Another subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[1] != groups[2]\u003C/code\u003E. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is \u003Ccode\u003E2\u003C/code\u003E.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\u0022example\u0022\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\u0022example-block\u0022 style=\u0022\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\u0022\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003Ewords = [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;], groups = [1,0,1,1]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E A subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[1]\u003C/code\u003E and \u003Ccode\u003Egroups[1] != groups[2]\u003C/code\u003E. Another subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;d\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[1]\u003C/code\u003E and \u003Ccode\u003Egroups[1] != groups[3]\u003C/code\u003E. It can be shown that the length of the longest subsequence of indices that satisfies the condition is \u003Ccode\u003E3\u003C/code\u003E.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u0026nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 \u0026lt;= n == words.length == groups.length \u0026lt;= 100\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 \u0026lt;= words[i].length \u0026lt;= 10\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egroups[i]\u003C/code\u003E is either \u003Ccode\u003E0\u003C/code\u003E or \u003Ccode\u003E1.\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ewords\u003C/code\u003E consists of \u003Cstrong\u003Edistinct\u003C/strong\u003E strings.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ewords[i]\u003C/code\u003E consists of lowercase English letters.\u003C/li\u003E\n\u003C/ul\u003E\n",
  "description": "\u003Cp\u003EYou are given a string array \u003Ccode\u003Ewords\u003C/code\u003E and a \u003Cstrong\u003Ebinary\u003C/strong\u003E array \u003Ccode\u003Egroups\u003C/code\u003E both of length \u003Ccode\u003En\u003C/code\u003E, where \u003Ccode\u003Ewords[i]\u003C/code\u003E is associated with \u003Ccode\u003Egroups[i]\u003C/code\u003E.\u003C/p\u003E\n\n\u003Cp\u003EYour task is to select the \u003Cstrong\u003Elongest alternating\u003C/strong\u003E \u003Cspan data-keyword=\u0022subsequence-array\u0022\u003Esubsequence\u003C/span\u003E from \u003Ccode\u003Ewords\u003C/code\u003E. A subsequence of \u003Ccode\u003Ewords\u003C/code\u003E is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array \u003Ccode\u003Egroups\u003C/code\u003E differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the \u003Ccode\u003Egroups\u003C/code\u003E array.\u003C/p\u003E\n\n\u003Cp\u003EFormally, you need to find the longest subsequence of an array of indices \u003Ccode\u003E[0, 1, ..., n - 1]\u003C/code\u003E denoted as \u003Ccode\u003E[i\u003Csub\u003E0\u003C/sub\u003E, i\u003Csub\u003E1\u003C/sub\u003E, ..., i\u003Csub\u003Ek-1\u003C/sub\u003E]\u003C/code\u003E, such that \u003Ccode\u003Egroups[i\u003Csub\u003Ej\u003C/sub\u003E] != groups[i\u003Csub\u003Ej\u002B1\u003C/sub\u003E]\u003C/code\u003E for each \u003Ccode\u003E0 \u0026lt;= j \u0026lt; k - 1\u003C/code\u003E and then find the words corresponding to these indices.\u003C/p\u003E\n\n\u003Cp\u003EReturn \u003Cem\u003Ethe selected subsequence. If there are multiple answers, return \u003Cstrong\u003Eany\u003C/strong\u003E of them.\u003C/em\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003ENote:\u003C/strong\u003E The elements in \u003Ccode\u003Ewords\u003C/code\u003E are distinct.\u003C/p\u003E\n\n\u003Cp\u003E\u0026nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong class=\u0022example\u0022\u003EExample 1:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\u0022example-block\u0022 style=\u0022\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\u0022\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003Ewords = [\u0026quot;e\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;], groups = [0,0,1]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003E[\u0026quot;e\u0026quot;,\u0026quot;b\u0026quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E A subsequence that can be selected is \u003Ccode\u003E[\u0026quot;e\u0026quot;,\u0026quot;b\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[2]\u003C/code\u003E. Another subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[1] != groups[2]\u003C/code\u003E. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is \u003Ccode\u003E2\u003C/code\u003E.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u003Cstrong class=\u0022example\u0022\u003EExample 2:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cdiv class=\u0022example-block\u0022 style=\u0022\n    border-color: var(--border-tertiary);\n    border-left-width: 2px;\n    color: var(--text-secondary);\n    font-size: .875rem;\n    margin-bottom: 1rem;\n    margin-top: 1rem;\n    overflow: visible;\n    padding-left: 1rem;\n\u0022\u003E\n\u003Cp\u003E\u003Cstrong\u003EInput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003Ewords = [\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;d\u0026quot;], groups = [1,0,1,1]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EOutput:\u003C/strong\u003E \u003Cspan class=\u0022example-io\u0022 style=\u0022\n    font-family: Menlo,sans-serif;\n    font-size: 0.85rem;\n\u0022\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\u003C/span\u003E\u003C/p\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExplanation:\u003C/strong\u003E A subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[1]\u003C/code\u003E and \u003Ccode\u003Egroups[1] != groups[2]\u003C/code\u003E. Another subsequence that can be selected is \u003Ccode\u003E[\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;d\u0026quot;]\u003C/code\u003E because \u003Ccode\u003Egroups[0] != groups[1]\u003C/code\u003E and \u003Ccode\u003Egroups[1] != groups[3]\u003C/code\u003E. It can be shown that the length of the longest subsequence of indices that satisfies the condition is \u003Ccode\u003E3\u003C/code\u003E.\u003C/p\u003E\n\u003C/div\u003E\n\n\u003Cp\u003E\u0026nbsp;\u003C/p\u003E\n\u003Cp\u003E\u003Cstrong\u003EConstraints:\u003C/strong\u003E\u003C/p\u003E\n\n\u003Cul\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 \u0026lt;= n == words.length == groups.length \u0026lt;= 100\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003E1 \u0026lt;= words[i].length \u0026lt;= 10\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Egroups[i]\u003C/code\u003E is either \u003Ccode\u003E0\u003C/code\u003E or \u003Ccode\u003E1.\u003C/code\u003E\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ewords\u003C/code\u003E consists of \u003Cstrong\u003Edistinct\u003C/strong\u003E strings.\u003C/li\u003E\n\t\u003Cli\u003E\u003Ccode\u003Ewords[i]\u003C/code\u003E consists of lowercase English letters.\u003C/li\u003E\n\u003C/ul\u003E\n",
  "example": "[\u0022c\u0022]\n[0]\n[\u0022d\u0022]\n[1]",
  "constraints": "",
  "solution": "",
  "explanation": "",
  "exampleTestcases": "[\u0022c\u0022]\n[0]\n[\u0022d\u0022]\n[1]",
  "categoryTitle": "Algorithms",
  "topicTags": [
    {
      "name": "Array",
      "id": "",
      "slug": "array"
    },
    {
      "name": "String",
      "id": "",
      "slug": "string"
    },
    {
      "name": "Dynamic Programming",
      "id": "",
      "slug": "dynamic-programming"
    },
    {
      "name": "Greedy",
      "id": "",
      "slug": "greedy"
    }
  ],
  "acRate": 0,
  "frequency": 0,
  "status": ""
}